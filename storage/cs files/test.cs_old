using System.Numerics;
using Raylib_cs;
using static Raylib_cs.Raylib;
using static Raylib_cs.Color;
using static Raylib_cs.KeyboardKey;
using Color = Raylib_cs.Color;

namespace MrCrossDrivesAnSTypeJaguar;

class Test
{

    const int GLSL_VERSION = 330;
    public static void test()
    {
        float MinValue(float a, float b)
        {  
            if(a < b)
            {
                return a;
            }
            else
            {
                return b;
            }
        }

        float MaxValue(float a, float b)
        {  
            if(a > b)
            {
                return a;
            }  
            else
            {
                return b;
            }
        }

        //----------------------------------------------INIT-------------------------------------------------

        Raylib.InitWindow(600, 350, "Fahoom Projectile Motion Simulator");
        
        //vars
        float screeny = GetScreenHeight() / 2;
        float screenx = GetScreenWidth() / 2;

        List<Vector3> trail2 = new List<Vector3>();

        //Models
        Model sphere2 = LoadModelFromMesh(GenMeshSphere(1.0f, 25, 25));

        float minCamX = float.PositiveInfinity;
        float maxCamX = float.NegativeInfinity;
        float minCamY = float.PositiveInfinity;
        float maxCamY = float.NegativeInfinity;
        
        float currentSpeed = 20f;
        float userDeg = 45;
        float initialAngleRad = userDeg * 1/180 * (float)Math.PI;
        float mass = 100f;
        float crossectionalArea = 2f;
        float p = 1.293f;
        float earthRadius = 6371000f;
        float earthMass = 5.972e24f;
        float bigG = 6.67e-11f;
        //slider for dT / "accuracy of simulation"
        float dT = 0.016f;

        float magnitudeOfFDTG = -(bigG * earthMass * mass)/(earthRadius * earthRadius);
        float magnitudeOfFDTD = ((-p * crossectionalArea)/4) * currentSpeed * currentSpeed;

        //Vectors
        //Vector3 camPos = new Vector3(0, 0, 50);
        //Vector3 targetPos = new Vector3(0, 0, 0);
        List<Vector3> trail = new List<Vector3>();
        Vector currentVelocity = new Vector(userDeg, currentSpeed, 0, true);
        Vector forceDueToGravity = new Vector(0, magnitudeOfFDTG, 0);
        Vector forceDueToDrag = currentVelocity.unitVector().Scale(magnitudeOfFDTD);
        Vector totalForce = forceDueToDrag.addVector(forceDueToGravity);
        Vector currentPosition = new Vector(0, 0, 0);
        Vector currentAcceleration;

        //Models
        Model sphere = LoadModelFromMesh(GenMeshSphere(1.0f, 25, 25));
        Model plane = LoadModelFromMesh(GenMeshSphere(1.0f, 25, 25));

        //Shaders
        Shader shader = LoadShader(
            "lighting.vs",
            "lighting.fs"
        );

        //Vector testVec = new Vector((float)(Math.Atan(1/Math.Sqrt(2))), (float)Math.Sqrt(3), (float)(Math.PI)/4, true);
        Vector testVec2 = new Vector(0, 0, 0, false);
        //Console.WriteLine(testVec.debugLogVector());
        //Vector unitTestVec = testVec.unitVector();
        //Console.WriteLine(unitTestVec.debugLogVector());
        //Console.WriteLine(unitTestVec.Magnitude());

        //Console.WriteLine(testVec.subVector(testVec2).debugLogVector());
        Console.WriteLine(testVec2.getVector3().X);
        Console.WriteLine(testVec2.getVector3().Y);
        Console.WriteLine(testVec2.getVector3().Z);

        //fps setting
        SetTargetFPS(60);

        //----------------------------------------------NOTES------------------------------------------------

        // store values in an array, add slider for playback, possible add ffmpeg support for baking video?
        // play/pause
        // Make frame counter that is affected by play and pause
        
        //--------------------------------------------RENDERING----------------------------------------------
        
        while (!Raylib.WindowShouldClose())
        {
            //Camera
            Camera3D camera = new();
            
            camera.Up = new Vector3(0.0f, 1.0f, 0.0f);          // Camera up vector (rotation towards target)
            camera.FovY = 60.0f;                                // Camera field-of-view Y  
            camera.Projection = CameraProjection.CAMERA_PERSPECTIVE;

            //vars
            //initial speed
            //inital angle
            //Mass
            //Diameter
            //Time
            // F = mg - cv^2

            /*
            float verSpeed = initialSpeed * (float)Math.Sin(initialAngleRad);
            float horSpeed = initialSpeed * (float)Math.Cos(initialAngleRad);
            
            float force = (mass * gravac) - ((float)Math.PI/16 * (p  * diameter * diameter) * (initialSpeed * initialSpeed));
            float acceleration = force / mass;
            float velocity = acceleration * (float)time;
            float distance = velocity * (float)deltaTime;
            Console.WriteLine(force);

            float horDistance = initialSpeed * (float)deltaTime;
            */

            currentSpeed = currentVelocity.Magnitude();
            magnitudeOfFDTG = -(bigG * earthMass * mass)/(earthRadius * earthRadius);
            magnitudeOfFDTD = ((-p * crossectionalArea)/4) * currentSpeed * currentSpeed;

            forceDueToGravity = new Vector(0, magnitudeOfFDTG, 0);
            forceDueToDrag = currentVelocity.unitVector().Scale(magnitudeOfFDTD);
            totalForce = forceDueToDrag.addVector(forceDueToGravity);

            currentAcceleration = totalForce.Scale(1/mass);
            // v = u + at
            currentVelocity = currentVelocity.addVector(currentAcceleration.Scale(dT));
            // s = vt - 1/2at^2
            currentPosition = currentPosition.addVector(currentVelocity.Scale(dT).subVector(currentAcceleration.Scale(0.5f * dT * dT)));
            
            

            float dY = maxCamY - minCamY;
            float dX = maxCamX - minCamX;

            

            float vecX = 0;
            float vecY = 0;
            float vecZ = 0;
            
            //Vectors
           
            Vector3 StartPos = new Vector3(0, 0, 0);
            Vector3 CurrentPos = new Vector3(vecX, vecY, vecZ);
            Vector3 vecsphere = new Vector3(vecX, vecY, vecZ);
            Vector3 displacementvec = CurrentPos - StartPos;
            Vector2 k = GetWorldToScreen(CurrentPos, camera);            

            //calc
            float displacement = (float)Math.Sqrt(displacementvec.Y * displacementvec.Y + displacementvec.Z * displacementvec.Z);

            //vars
            float gravac = -9.81f;
            float speed = 17f;
            float vspeed;
            float hspeed;
            float degVerAngle = 45f; //angle to the vertical, e.g. straight up is 0, horizontal is 90
            float radVerAngle = degVerAngle * 1/180 * (float)Math.PI;
            float degHorAngle = 90f; //angle to the horizontal
            float radHorAngle = degHorAngle * 1/180 * (float)Math.PI;
            float t = 0;
            double posY;
            double posXZ;
            double deltaTime = GetTime();
            deltaTime = deltaTime - t;
            
            //calc
            //s = ut + 1/2(a(t^2))
            vspeed = speed * (float)Math.Cos(radVerAngle);
            hspeed = speed * (float)Math.Sin(radVerAngle);

            posY = vspeed * deltaTime + 0.5 * gravac * deltaTime * deltaTime;
            posXZ = deltaTime * hspeed;

            //positioning
            float vecX2 = (float)(posXZ * Math.Sin(radHorAngle));
            float vecY2 = (float)posY;
            float vecZ2 = (float)(posXZ * Math.Cos(radHorAngle));
            
            //Vectors
            Vector3 StartPos2 = new Vector3(0, 0, 0);
            Vector3 CurrentPos2 = new Vector3(vecX2, vecY2, vecZ2);
            Vector3 vecsphere2 = new Vector3(vecX2, vecY2, vecZ2);
            Vector3 displacementvec2 = CurrentPos - StartPos;

            float maxCamDistance = MaxValue(dY, dX);
            float maxCamZDistance = maxCamDistance / (2 * (float)Math.Tan(((camera.FovY/180)*Math.PI)/2));
            float averageCamYDistance = (maxCamY + minCamY)/2;
            float averageCamXDistance = (maxCamX + minCamX)/2;
            Vector camPos = new Vector(averageCamXDistance, averageCamYDistance, maxCamZDistance * (float)1.1);
            Vector targetPos = new Vector(averageCamXDistance, averageCamYDistance, 0);
            camera.Position = camPos.getVector3();
            camera.Target = targetPos.getVector3();

            minCamX = MinValue(CurrentPos2.X, minCamX);
            minCamY = MinValue(CurrentPos2.Y, minCamY);
            maxCamX = MaxValue(CurrentPos2.X, maxCamX);
            maxCamY = MaxValue(CurrentPos2.Y, maxCamY);

            //calc
            float displacement2 = (float)Math.Sqrt(displacementvec.Y * displacementvec.Y + displacementvec.Z * displacementvec.Z);

            //hide cursor
            //DisableCursor();

            //---------------------------------------------DRAWING-----------------------------------------------

            Raylib.BeginDrawing();
            Raylib.ClearBackground(WHITE);
            
            //2D Objects
            //DrawCircle((int)screenx, (int)screeny, 2.5f, Color.GREEN);

            Raylib.BeginMode3D(camera);

                //Grid
                DrawGrid(200, 1);

                //3D Objects
                DrawModel(sphere, currentPosition.getVector3(), 0.5f, Color.BLUE);

                DrawModel(sphere, vecsphere2, 1.0f, Color.BLUE);
                
                //Lines
                DrawLine3D(StartPos, currentPosition.getVector3(), Color.GREEN);
                trail.Add(currentPosition.getVector3());
                if(trail.Count > 1)
                {
                    for(int i = 1; i < trail.Count; i++)
                    {
                        Raylib.DrawLine3D(trail[i-1], trail[i], Color.RED);
                    }
                }

                DrawLine3D(StartPos2, CurrentPos2, Color.GREEN);
                trail2.Add(CurrentPos2);
                if(trail.Count > 1)
                {
                    for(int i = 1; i < trail2.Count; i++)
                    {
                        Raylib.DrawLine3D(trail2[i-1], trail2[i], Color.RED);
                    }
                }

            Raylib.EndMode3D();

            //Raylib.DrawText("Fahoom Projectile Motion Renderer", 20,  10, 20, Color.BLACK);
            //Raylib.DrawText(k.ToString(), 20,  10, 20, Color.BLACK);
            //Raylib.DrawText("X Vector: " + vecX.ToString(), 20, 40, 20, Color.BLACK);
            //Raylib.DrawText("Y Vector: " + vecY.ToString(), 20, 70, 20, Color.BLACK);
            Raylib.DrawText("Current Speed: " + currentSpeed, 20, 100, 20, Color.BLACK);
            
            DrawFPS(510, 10);
        
            Raylib.EndDrawing();
        }

        Raylib.CloseWindow();
    }
}